package com.coder.util;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringUtil {
	public static final String PROPERTY_SEPARATOR = ",";
	public static final String VALUE_SEPARATOR = "=";
	public static final String COMMA_SEPARATED_VALUES_SEPARATOR = ",";
	public static final String SQL_IN_START = "('";
	public static final String SQL_IN_END = "')";
	public static final String SQL_IN_VALUES_SEPARATOR = "','";
	private static final HashMap<String, Character> entityToChar;
	static {
		// build HashMap to look up entity name to get corresponding Unicode
		// char number. Following code generated by Entities.
		String[] entityKeys = {
				"quot"/* 34 : &#x22; quotation mark */,
				"amp"/* 38 : &#x26; ampersand */,
				"lt"/* 60 : &#x3c; less-than sign */,
				"gt"/* 62 : &#x3e; greater-than sign */,
				"nbsp"/* 160 : &#xa0; non-breaking space */,
				"iexcl"/* 161 : &#xa1; inverted exclamation mark */,
				"cent"/* 162 : &#xa2; cent sign */,
				"pound"/* 163 : &#xa3; pound sign */,
				"curren"/* 164 : &#xa4; currency sign */,
				"yen"/* 165 : &#xa5; yen sign */,
				"brvbar"/* 166 : &#xa6; broken bar */,
				"sect"/* 167 : &#xa7; section sign */,
				"uml"/* 168 : &#xa8; diaeresis */,
				"copy"/* 169 : &#xa9; copyright sign */,
				"ordf"/* 170 : &#xaa; feminine ordinal indicator */,
				"laquo"/* 171 : &#xab; left guillemot */,
				"not"/* 172 : &#xac; not sign */,
				"shy"/* 173 : &#xad; soft hyphen */,
				"reg"/* 174 : &#xae; registered sign */,
				"macr"/* 175 : &#xaf; macron */,
				"deg"/* 176 : &#xb0; degree sign */,
				"plusmn"/* 177 : &#xb1; plus-minus sign */,
				"sup2"/* 178 : &#xb2; superscript two */,
				"sup3"/* 179 : &#xb3; superscript three */,
				"acute"/* 180 : &#xb4; acute accent */,
				"micro"/* 181 : &#xb5; micro sign */,
				"para"/* 182 : &#xb6; pilcrow sign */,
				"middot"/* 183 : &#xb7; middle dot */,
				"cedil"/* 184 : &#xb8; cedilla */,
				"sup1"/* 185 : &#xb9; superscript one */,
				"ordm"/* 186 : &#xba; masculine ordinal indicator */,
				"raquo"/* 187 : &#xbb; right guillemot */,
				"frac14"/* 188 : &#xbc; vulgar fraction 1/4 */,
				"frac12"/* 189 : &#xbd; vulgar fraction 1/2 */,
				"frac34"/* 190 : &#xbe; vulgar fraction 3/4 */,
				"iquest"/* 191 : &#xbf; inverted question mark */,
				"Agrave"/* 192 : &#xc0; Latin capital letter A with grave */,
				"Aacute"/* 193 : &#xc1; Latin capital letter A with acute */,
				"Acirc"/* 194 : &#xc2; Latin capital letter A with circumflex */,
				"Atilde"/* 195 : &#xc3; Latin capital letter A with tilde */,
				"Auml"/* 196 : &#xc4; Latin capital letter A with diaeresis */,
				"Aring"/* 197 : &#xc5; Latin capital letter A with ring above */,
				"AElig"/* 198 : &#xc6; Latin capital letter AE */,
				"Ccedil"/* 199 : &#xc7; Latin capital letter C with cedilla */,
				"Egrave"/* 200 : &#xc8; Latin capital letter E with grave */,
				"Eacute"/* 201 : &#xc9; Latin capital letter E with acute */,
				"Ecirc"/* 202 : &#xca; Latin capital letter E with circumflex */,
				"Euml"/* 203 : &#xcb; Latin capital letter E with diaeresis */,
				"Igrave"/* 204 : &#xcc; Latin capital letter I with grave */,
				"Iacute"/* 205 : &#xcd; Latin capital letter I with acute */,
				"Icirc"/* 206 : &#xce; Latin capital letter I with circumflex */,
				"Iuml"/* 207 : &#xcf; Latin capital letter I with diaeresis */,
				"ETH"/* 208 : &#xd0; Latin capital letter eth */,
				"Ntilde"/* 209 : &#xd1; Latin capital letter N with tilde */,
				"Ograve"/* 210 : &#xd2; Latin capital letter O with grave */,
				"Oacute"/* 211 : &#xd3; Latin capital letter O with acute */,
				"Ocirc"/* 212 : &#xd4; Latin capital letter O with circumflex */,
				"Otilde"/* 213 : &#xd5; Latin capital letter O with tilde */,
				"Ouml"/* 214 : &#xd6; Latin capital letter O with diaeresis */,
				"times"/* 215 : &#xd7; multiplication sign */,
				"Oslash"/* 216 : &#xd8; Latin capital letter O with stroke */,
				"Ugrave"/* 217 : &#xd9; Latin capital letter U with grave */,
				"Uacute"/* 218 : &#xda; Latin capital letter U with acute */,
				"Ucirc"/* 219 : &#xdb; Latin capital letter U with circumflex */,
				"Uuml"/* 220 : &#xdc; Latin capital letter U with diaeresis */,
				"Yacute"/* 221 : &#xdd; Latin capital letter Y with acute */,
				"THORN"/* 222 : &#xde; Latin capital letter Thorn */,
				"szlig"/* 223 : &#xdf; Latin small letter sharp s */,
				"agrave"/* 224 : &#xe0; Latin small letter a with grave */,
				"aacute"/* 225 : &#xe1; Latin small letter a with acute */,
				"acirc"/* 226 : &#xe2; Latin small letter a with circumflex */,
				"atilde"/* 227 : &#xe3; Latin small letter a with tilde */,
				"auml"/* 228 : &#xe4; Latin small letter a with diaeresis */,
				"aring"/* 229 : &#xe5; Latin small letter a with ring above */,
				"aelig"/* 230 : &#xe6; Latin lowercase ligature ae */,
				"ccedil"/* 231 : &#xe7; Latin small letter c with cedilla */,
				"egrave"/* 232 : &#xe8; Latin small letter e with grave */,
				"eacute"/* 233 : &#xe9; Latin small letter e with acute */,
				"ecirc"/* 234 : &#xea; Latin small letter e with circumflex */,
				"euml"/* 235 : &#xeb; Latin small letter e with diaeresis */,
				"igrave"/* 236 : &#xec; Latin small letter i with grave */,
				"iacute"/* 237 : &#xed; Latin small letter i with acute */,
				"icirc"/* 238 : &#xee; Latin small letter i with circumflex */,
				"iuml"/* 239 : &#xef; Latin small letter i with diaeresis */,
				"eth"/* 240 : &#xf0; Latin small letter eth */,
				"ntilde"/* 241 : &#xf1; Latin small letter n with tilde */,
				"ograve"/* 242 : &#xf2; Latin small letter o with grave */,
				"oacute"/* 243 : &#xf3; Latin small letter o with acute */,
				"ocirc"/* 244 : &#xf4; Latin small letter o with circumflex */,
				"otilde"/* 245 : &#xf5; Latin small letter o with tilde */,
				"ouml"/* 246 : &#xf6; Latin small letter o with diaeresis */,
				"divide"/* 247 : &#xf7; division sign */,
				"oslash"/* 248 : &#xf8; Latin small letter o with stroke */,
				"ugrave"/* 249 : &#xf9; Latin small letter u with grave */,
				"uacute"/* 250 : &#xfa; Latin small letter u with acute */,
				"ucirc"/* 251 : &#xfb; Latin small letter u with circumflex */,
				"uuml"/* 252 : &#xfc; Latin small letter u with diaeresis */,
				"yacute"/* 253 : &#xfd; Latin small letter y with acute */,
				"thorn"/* 254 : &#xfe; Latin small letter thorn */,
				"yuml"/* 255 : &#xff; Latin small letter y with diaeresis */,
				"OElig"/* 338 : &#x152; Latin capital ligature oe */,
				"oelig"/* 339 : &#x153; Latin small ligature oe */,
				"Scaron"/* 352 : &#x160; Latin capital letter S with caron */,
				"scaron"/* 353 : &#x161; Latin small letter s with caron */,
				"Yuml"/* 376 : &#x178; Latin capital letter Y with diaeresis */,
				"fnof"/* 402 : &#x192; Latin small letter f with hook */,
				"circ"/* 710 : &#x2c6; modifier letter circumflex accent */,
				"tilde"/* 732 : &#x2dc; small tilde */,
				"Alpha"/* 913 : &#x391; Greek capital letter Alpha */,
				"Beta"/* 914 : &#x392; Greek capital letter Beta */,
				"Gamma"/* 915 : &#x393; Greek capital letter Gamma */,
				"Delta"/* 916 : &#x394; Greek capital letter Delta */,
				"Epsilon"/* 917 : &#x395; Greek capital letter Epsilon */,
				"Zeta"/* 918 : &#x396; Greek capital letter Zeta */,
				"Eta"/* 919 : &#x397; Greek capital letter Eta */,
				"Theta"/* 920 : &#x398; Greek capital letter Theta */,
				"Iota"/* 921 : &#x399; Greek capital letter Iota */,
				"Kappa"/* 922 : &#x39a; Greek capital letter Kappa */,
				"Lambda"/* 923 : &#x39b; Greek capital letter Lambda */,
				"Mu"/* 924 : &#x39c; Greek capital letter Mu */,
				"Nu"/* 925 : &#x39d; Greek capital letter Nu */,
				"Xi"/* 926 : &#x39e; Greek capital letter Xi */,
				"Omicron"/* 927 : &#x39f; Greek capital letter Omicron */,
				"Pi"/* 928 : &#x3a0; Greek capital letter Pi */,
				"Rho"/* 929 : &#x3a1; Greek capital letter Rho */,
				"Sigma"/* 931 : &#x3a3; Greek capital letter Sigma */,
				"Tau"/* 932 : &#x3a4; Greek capital letter Tau */,
				"Upsilon"/* 933 : &#x3a5; Greek capital letter Upsilon */,
				"Phi"/* 934 : &#x3a6; Greek capital letter Phi */,
				"Chi"/* 935 : &#x3a7; Greek capital letter Chi */,
				"Psi"/* 936 : &#x3a8; Greek capital letter Psi */,
				"Omega"/* 937 : &#x3a9; Greek capital letter Omega */,
				"alpha"/* 945 : &#x3b1; Greek small letter alpha */,
				"beta"/* 946 : &#x3b2; Greek small letter beta */,
				"gamma"/* 947 : &#x3b3; Greek small letter gamma */,
				"delta"/* 948 : &#x3b4; Greek small letter delta */,
				"epsilon"/* 949 : &#x3b5; Greek small letter epsilon */,
				"zeta"/* 950 : &#x3b6; Greek small letter zeta */,
				"eta"/* 951 : &#x3b7; Greek small letter eta */,
				"theta"/* 952 : &#x3b8; Greek small letter theta */,
				"iota"/* 953 : &#x3b9; Greek small letter iota */,
				"kappa"/* 954 : &#x3ba; Greek small letter kappa */,
				"lambda"/* 955 : &#x3bb; Greek small letter lambda */,
				"mu"/* 956 : &#x3bc; Greek small letter mu */,
				"nu"/* 957 : &#x3bd; Greek small letter nu */,
				"xi"/* 958 : &#x3be; Greek small letter xi */,
				"omicron"/* 959 : &#x3bf; Greek small letter omicron */,
				"pi"/* 960 : &#x3c0; Greek small letter pi */,
				"rho"/* 961 : &#x3c1; Greek small letter rho */,
				"sigmaf"/* 962 : &#x3c2; Greek small letter final sigma */,
				"sigma"/* 963 : &#x3c3; Greek small letter sigma */,
				"tau"/* 964 : &#x3c4; Greek small letter tau */,
				"upsilon"/* 965 : &#x3c5; Greek small letter upsilon */,
				"phi"/* 966 : &#x3c6; Greek small letter phi */,
				"chi"/* 967 : &#x3c7; Greek small letter chi */,
				"psi"/* 968 : &#x3c8; Greek small letter psi */,
				"omega"/* 969 : &#x3c9; Greek small letter omega */,
				"thetasym"/* 977 : &#x3d1; Greek theta symbol */,
				"upsih"/* 978 : &#x3d2; Greek upsilon with hook symbol */,
				"piv"/* 982 : &#x3d6; Greek pi symbol */,
				"ensp"/* 8194 : &#x2002; en space */,
				"emsp"/* 8195 : &#x2003; em space */,
				"thinsp"/* 8201 : &#x2009; thin space */,
				"zwnj"/* 8204 : &#x200c; zero width non-joiner */,
				"zwj"/* 8205 : &#x200d; zero width joiner */,
				"lrm"/* 8206 : &#x200e; left-to-right mark */,
				"rlm"/* 8207 : &#x200f; right-to-left mark */,
				"ndash"/* 8211 : &#x2013; en dash */,
				"mdash"/* 8212 : &#x2014; em dash */,
				"lsquo"/* 8216 : &#x2018; left single-6 quotation mark */,
				"rsquo"/* 8217 : &#x2019; right single-9 quotation mark */,
				"sbquo"/* 8218 : &#x201a; single low-9 quotation mark */,
				"ldquo"/* 8220 : &#x201c; left double-66 quotation mark */,
				"rdquo"/* 8221 : &#x201d; right double-99 quotation mark */,
				"bdquo"/* 8222 : &#x201e; double low-99 quotation mark */,
				"dagger"/* 8224 : &#x2020; dagger */,
				"Dagger"/* 8225 : &#x2021; double dagger */,
				"bull"/* 8226 : &#x2022; bullet */,
				"hellip"/* 8230 : &#x2026; horizontal ellipsis */,
				"permil"/* 8240 : &#x2030; per mille sign */,
				"prime"/* 8242 : &#x2032; prime */,
				"Prime"/* 8243 : &#x2033; double prime */,
				"lsaquo"/*
						 * 8249 : &#x2039; single left-pointing angle quotation
						 * mark
						 */, "rsaquo"/*
									 * 8250 : &#x203a; single right-pointing
									 * angle quotation mark
									 */, "oline"/* 8254 : &#x203e; overline */,
				"frasl"/* 8260 : &#x2044; fraction slash */,
				"euro"/* 8364 : &#x20ac; Euro currency sign */,
				"image"/* 8465 : &#x2111; black-letter capital i */,
				"weierp"/* 8472 : &#x2118; script capital p */,
				"real"/* 8476 : &#x211c; black-letter capital r */,
				"trade"/* 8482 : &#x2122; trademark sign */,
				"alefsym"/* 8501 : &#x2135; alef symbol */,
				"larr"/* 8592 : &#x2190; leftwards arrow */,
				"uarr"/* 8593 : &#x2191; upwards arrow */,
				"rarr"/* 8594 : &#x2192; rightwards arrow */,
				"darr"/* 8595 : &#x2193; downwards arrow */,
				"harr"/* 8596 : &#x2194; left right arrow */,
				"crarr"/*
						 * 8629 : &#x21b5; downwards arrow with corner leftwards
						 */, "lArr"/* 8656 : &#x21d0; leftwards double arrow */,
				"uArr"/* 8657 : &#x21d1; upwards double arrow */,
				"rArr"/* 8658 : &#x21d2; rightwards double arrow */,
				"dArr"/* 8659 : &#x21d3; downwards double arrow */,
				"hArr"/* 8660 : &#x21d4; left right double arrow */,
				"forall"/* 8704 : &#x2200; for all */,
				"part"/* 8706 : &#x2202; partial differential */,
				"exist"/* 8707 : &#x2203; there exists */,
				"empty"/* 8709 : &#x2205; empty set */,
				"nabla"/* 8711 : &#x2207; nabla */,
				"isin"/* 8712 : &#x2208; element of */,
				"notin"/* 8713 : &#x2209; not an element of */,
				"ni"/* 8715 : &#x220b; contains as member */,
				"prod"/* 8719 : &#x220f; n-ary product */,
				"sum"/* 8721 : &#x2211; n-ary summation */,
				"minus"/* 8722 : &#x2212; minus sign */,
				"lowast"/* 8727 : &#x2217; asterisk operator */,
				"radic"/* 8730 : &#x221a; square root */,
				"prop"/* 8733 : &#x221d; proportional to */,
				"infin"/* 8734 : &#x221e; infinity */,
				"ang"/* 8736 : &#x2220; angle */,
				"and"/* 8743 : &#x2227; logical and */,
				"or"/* 8744 : &#x2228; logical or */,
				"cap"/* 8745 : &#x2229; intersection */,
				"cup"/* 8746 : &#x222a; union */,
				"int"/* 8747 : &#x222b; integral */,
				"there4"/* 8756 : &#x2234; therefore */,
				"sim"/* 8764 : &#x223c; tilde operator */,
				"cong"/* 8773 : &#x2245; congruent to */,
				"asymp"/* 8776 : &#x2248; asymptotic to */,
				"ne"/* 8800 : &#x2260; not equal to */,
				"equiv"/* 8801 : &#x2261; identical to */,
				"le"/* 8804 : &#x2264; less-than or equal to */,
				"ge"/* 8805 : &#x2265; greater-than or equal to */,
				"sub"/* 8834 : &#x2282; subset of */,
				"sup"/* 8835 : &#x2283; superset of */,
				"nsub"/* 8836 : &#x2284; not a subset of */,
				"sube"/* 8838 : &#x2286; subset of or equal to */,
				"supe"/* 8839 : &#x2287; superset of or equal to */,
				"oplus"/* 8853 : &#x2295; circled plus */,
				"otimes"/* 8855 : &#x2297; circled times */,
				"perp"/* 8869 : &#x22a5; up tack */,
				"sdot"/* 8901 : &#x22c5; dot operator */,
				"lceil"/* 8968 : &#x2308; left ceiling */,
				"rceil"/* 8969 : &#x2309; right ceiling */,
				"lfloor"/* 8970 : &#x230a; left floor */,
				"rfloor"/* 8971 : &#x230b; right floor */,
				"lang"/* 9001 : &#x2329; left-pointing angle bracket */,
				"rang"/* 9002 : &#x232a; right-pointing angle bracket */,
				"loz"/* 9674 : &#x25ca; lozenge */,
				"spades"/* 9824 : &#x2660; black spade suit */,
				"clubs"/* 9827 : &#x2663; black club suit */,
				"hearts"/* 9829 : &#x2665; black heart suit */,
				"diams"/* 9830 : &#x2666; black diamond suit */, };
		char[] entityValues = {
				34/* &quot; : &#x22; quotation mark */,
				38/* &amp; : &#x26; ampersand */,
				60/* &lt; : &#x3c; less-than sign */,
				62/* &gt; : &#x3e; greater-than sign */,
				160/* &nbsp; : &#xa0; non-breaking space */,
				161/* &iexcl; : &#xa1; inverted exclamation mark */,
				162/* &cent; : &#xa2; cent sign */,
				163/* &pound; : &#xa3; pound sign */,
				164/* &curren; : &#xa4; currency sign */,
				165/* &yen; : &#xa5; yen sign */,
				166/* &brvbar; : &#xa6; broken bar */,
				167/* &sect; : &#xa7; section sign */,
				168/* &uml; : &#xa8; diaeresis */,
				169/* &copy; : &#xa9; copyright sign */,
				170/* &ordf; : &#xaa; feminine ordinal indicator */,
				171/* &laquo; : &#xab; left guillemot */,
				172/* &not; : &#xac; not sign */,
				173/* &shy; : &#xad; soft hyphen */,
				174/* &reg; : &#xae; registered sign */,
				175/* &macr; : &#xaf; macron */,
				176/* &deg; : &#xb0; degree sign */,
				177/* &plusmn; : &#xb1; plus-minus sign */,
				178/* &sup2; : &#xb2; superscript two */,
				179/* &sup3; : &#xb3; superscript three */,
				180/* &acute; : &#xb4; acute accent */,
				181/* &micro; : &#xb5; micro sign */,
				182/* &para; : &#xb6; pilcrow sign */,
				183/* &middot; : &#xb7; middle dot */,
				184/* &cedil; : &#xb8; cedilla */,
				185/* &sup1; : &#xb9; superscript one */,
				186/* &ordm; : &#xba; masculine ordinal indicator */,
				187/* &raquo; : &#xbb; right guillemot */,
				188/* &frac14; : &#xbc; vulgar fraction 1/4 */,
				189/* &frac12; : &#xbd; vulgar fraction 1/2 */,
				190/* &frac34; : &#xbe; vulgar fraction 3/4 */,
				191/* &iquest; : &#xbf; inverted question mark */,
				192/* &Agrave; : &#xc0; Latin capital letter A with grave */,
				193/* &Aacute; : &#xc1; Latin capital letter A with acute */,
				194/* &Acirc; : &#xc2; Latin capital letter A with circumflex */,
				195/* &Atilde; : &#xc3; Latin capital letter A with tilde */,
				196/* &Auml; : &#xc4; Latin capital letter A with diaeresis */,
				197/* &Aring; : &#xc5; Latin capital letter A with ring above */,
				198/* &AElig; : &#xc6; Latin capital letter AE */,
				199/* &Ccedil; : &#xc7; Latin capital letter C with cedilla */,
				200/* &Egrave; : &#xc8; Latin capital letter E with grave */,
				201/* &Eacute; : &#xc9; Latin capital letter E with acute */,
				202/* &Ecirc; : &#xca; Latin capital letter E with circumflex */,
				203/* &Euml; : &#xcb; Latin capital letter E with diaeresis */,
				204/* &Igrave; : &#xcc; Latin capital letter I with grave */,
				205/* &Iacute; : &#xcd; Latin capital letter I with acute */,
				206/* &Icirc; : &#xce; Latin capital letter I with circumflex */,
				207/* &Iuml; : &#xcf; Latin capital letter I with diaeresis */,
				208/* &ETH; : &#xd0; Latin capital letter eth */,
				209/* &Ntilde; : &#xd1; Latin capital letter N with tilde */,
				210/* &Ograve; : &#xd2; Latin capital letter O with grave */,
				211/* &Oacute; : &#xd3; Latin capital letter O with acute */,
				212/* &Ocirc; : &#xd4; Latin capital letter O with circumflex */,
				213/* &Otilde; : &#xd5; Latin capital letter O with tilde */,
				214/* &Ouml; : &#xd6; Latin capital letter O with diaeresis */,
				215/* &times; : &#xd7; multiplication sign */,
				216/* &Oslash; : &#xd8; Latin capital letter O with stroke */,
				217/* &Ugrave; : &#xd9; Latin capital letter U with grave */,
				218/* &Uacute; : &#xda; Latin capital letter U with acute */,
				219/* &Ucirc; : &#xdb; Latin capital letter U with circumflex */,
				220/* &Uuml; : &#xdc; Latin capital letter U with diaeresis */,
				221/* &Yacute; : &#xdd; Latin capital letter Y with acute */,
				222/* &THORN; : &#xde; Latin capital letter Thorn */,
				223/* &szlig; : &#xdf; Latin small letter sharp s */,
				224/* &agrave; : &#xe0; Latin small letter a with grave */,
				225/* &aacute; : &#xe1; Latin small letter a with acute */,
				226/* &acirc; : &#xe2; Latin small letter a with circumflex */,
				227/* &atilde; : &#xe3; Latin small letter a with tilde */,
				228/* &auml; : &#xe4; Latin small letter a with diaeresis */,
				229/* &aring; : &#xe5; Latin small letter a with ring above */,
				230/* &aelig; : &#xe6; Latin lowercase ligature ae */,
				231/* &ccedil; : &#xe7; Latin small letter c with cedilla */,
				232/* &egrave; : &#xe8; Latin small letter e with grave */,
				233/* &eacute; : &#xe9; Latin small letter e with acute */,
				234/* &ecirc; : &#xea; Latin small letter e with circumflex */,
				235/* &euml; : &#xeb; Latin small letter e with diaeresis */,
				236/* &igrave; : &#xec; Latin small letter i with grave */,
				237/* &iacute; : &#xed; Latin small letter i with acute */,
				238/* &icirc; : &#xee; Latin small letter i with circumflex */,
				239/* &iuml; : &#xef; Latin small letter i with diaeresis */,
				240/* &eth; : &#xf0; Latin small letter eth */,
				241/* &ntilde; : &#xf1; Latin small letter n with tilde */,
				242/* &ograve; : &#xf2; Latin small letter o with grave */,
				243/* &oacute; : &#xf3; Latin small letter o with acute */,
				244/* &ocirc; : &#xf4; Latin small letter o with circumflex */,
				245/* &otilde; : &#xf5; Latin small letter o with tilde */,
				246/* &ouml; : &#xf6; Latin small letter o with diaeresis */,
				247/* &divide; : &#xf7; division sign */,
				248/* &oslash; : &#xf8; Latin small letter o with stroke */,
				249/* &ugrave; : &#xf9; Latin small letter u with grave */,
				250/* &uacute; : &#xfa; Latin small letter u with acute */,
				251/* &ucirc; : &#xfb; Latin small letter u with circumflex */,
				252/* &uuml; : &#xfc; Latin small letter u with diaeresis */,
				253/* &yacute; : &#xfd; Latin small letter y with acute */,
				254/* &thorn; : &#xfe; Latin small letter thorn */,
				255/* &yuml; : &#xff; Latin small letter y with diaeresis */,
				338/* &OElig; : &#x152; Latin capital ligature oe */,
				339/* &oelig; : &#x153; Latin small ligature oe */,
				352/* &Scaron; : &#x160; Latin capital letter S with caron */,
				353/* &scaron; : &#x161; Latin small letter s with caron */,
				376/* &Yuml; : &#x178; Latin capital letter Y with diaeresis */,
				402/* &fnof; : &#x192; Latin small letter f with hook */,
				710/* &circ; : &#x2c6; modifier letter circumflex accent */,
				732/* &tilde; : &#x2dc; small tilde */,
				913/* &Alpha; : &#x391; Greek capital letter Alpha */,
				914/* &Beta; : &#x392; Greek capital letter Beta */,
				915/* &Gamma; : &#x393; Greek capital letter Gamma */,
				916/* &Delta; : &#x394; Greek capital letter Delta */,
				917/* &Epsilon; : &#x395; Greek capital letter Epsilon */,
				918/* &Zeta; : &#x396; Greek capital letter Zeta */,
				919/* &Eta; : &#x397; Greek capital letter Eta */,
				920/* &Theta; : &#x398; Greek capital letter Theta */,
				921/* &Iota; : &#x399; Greek capital letter Iota */,
				922/* &Kappa; : &#x39a; Greek capital letter Kappa */,
				923/* &Lambda; : &#x39b; Greek capital letter Lambda */,
				924/* &Mu; : &#x39c; Greek capital letter Mu */,
				925/* &Nu; : &#x39d; Greek capital letter Nu */,
				926/* &Xi; : &#x39e; Greek capital letter Xi */,
				927/* &Omicron; : &#x39f; Greek capital letter Omicron */,
				928/* &Pi; : &#x3a0; Greek capital letter Pi */,
				929/* &Rho; : &#x3a1; Greek capital letter Rho */,
				931/* &Sigma; : &#x3a3; Greek capital letter Sigma */,
				932/* &Tau; : &#x3a4; Greek capital letter Tau */,
				933/* &Upsilon; : &#x3a5; Greek capital letter Upsilon */,
				934/* &Phi; : &#x3a6; Greek capital letter Phi */,
				935/* &Chi; : &#x3a7; Greek capital letter Chi */,
				936/* &Psi; : &#x3a8; Greek capital letter Psi */,
				937/* &Omega; : &#x3a9; Greek capital letter Omega */,
				945/* &alpha; : &#x3b1; Greek small letter alpha */,
				946/* &beta; : &#x3b2; Greek small letter beta */,
				947/* &gamma; : &#x3b3; Greek small letter gamma */,
				948/* &delta; : &#x3b4; Greek small letter delta */,
				949/* &epsilon; : &#x3b5; Greek small letter epsilon */,
				950/* &zeta; : &#x3b6; Greek small letter zeta */,
				951/* &eta; : &#x3b7; Greek small letter eta */,
				952/* &theta; : &#x3b8; Greek small letter theta */,
				953/* &iota; : &#x3b9; Greek small letter iota */,
				954/* &kappa; : &#x3ba; Greek small letter kappa */,
				955/* &lambda; : &#x3bb; Greek small letter lambda */,
				956/* &mu; : &#x3bc; Greek small letter mu */,
				957/* &nu; : &#x3bd; Greek small letter nu */,
				958/* &xi; : &#x3be; Greek small letter xi */,
				959/* &omicron; : &#x3bf; Greek small letter omicron */,
				960/* &pi; : &#x3c0; Greek small letter pi */,
				961/* &rho; : &#x3c1; Greek small letter rho */,
				962/* &sigmaf; : &#x3c2; Greek small letter final sigma */,
				963/* &sigma; : &#x3c3; Greek small letter sigma */,
				964/* &tau; : &#x3c4; Greek small letter tau */,
				965/* &upsilon; : &#x3c5; Greek small letter upsilon */,
				966/* &phi; : &#x3c6; Greek small letter phi */,
				967/* &chi; : &#x3c7; Greek small letter chi */,
				968/* &psi; : &#x3c8; Greek small letter psi */,
				969/* &omega; : &#x3c9; Greek small letter omega */,
				977/* &thetasym; : &#x3d1; Greek theta symbol */,
				978/* &upsih; : &#x3d2; Greek upsilon with hook symbol */,
				982/* &piv; : &#x3d6; Greek pi symbol */,
				8194/* &ensp; : &#x2002; en space */,
				8195/* &emsp; : &#x2003; em space */,
				8201/* &thinsp; : &#x2009; thin space */,
				8204/* &zwnj; : &#x200c; zero width non-joiner */,
				8205/* &zwj; : &#x200d; zero width joiner */,
				8206/* &lrm; : &#x200e; left-to-right mark */,
				8207/* &rlm; : &#x200f; right-to-left mark */,
				8211/* &ndash; : &#x2013; en dash */,
				8212/* &mdash; : &#x2014; em dash */,
				8216/* &lsquo; : &#x2018; left single-6 quotation mark */,
				8217/* &rsquo; : &#x2019; right single-9 quotation mark */,
				8218/* &sbquo; : &#x201a; single low-9 quotation mark */,
				8220/* &ldquo; : &#x201c; left double-66 quotation mark */,
				8221/* &rdquo; : &#x201d; right double-99 quotation mark */,
				8222/* &bdquo; : &#x201e; double low-99 quotation mark */,
				8224/* &dagger; : &#x2020; dagger */,
				8225/* &Dagger; : &#x2021; double dagger */,
				8226/* &bull; : &#x2022; bullet */,
				8230/* &hellip; : &#x2026; horizontal ellipsis */,
				8240/* &permil; : &#x2030; per mille sign */,
				8242/* &prime; : &#x2032; prime */,
				8243/* &Prime; : &#x2033; double prime */,
				8249/*
					 * &lsaquo; : &#x2039; single left-pointing angle quotation
					 * mark
					 */, 8250/*
							 * &rsaquo; : &#x203a; single right-pointing angle
							 * quotation mark
							 */, 8254/* &oline; : &#x203e; overline */,
				8260/* &frasl; : &#x2044; fraction slash */,
				8364/* &euro; : &#x20ac; Euro currency sign */,
				8465/* &image; : &#x2111; black-letter capital i */,
				8472/* &weierp; : &#x2118; script capital p */,
				8476/* &real; : &#x211c; black-letter capital r */,
				8482/* &trade; : &#x2122; trademark sign */,
				8501/* &alefsym; : &#x2135; alef symbol */,
				8592/* &larr; : &#x2190; leftwards arrow */,
				8593/* &uarr; : &#x2191; upwards arrow */,
				8594/* &rarr; : &#x2192; rightwards arrow */,
				8595/* &darr; : &#x2193; downwards arrow */,
				8596/* &harr; : &#x2194; left right arrow */,
				8629/*
					 * &crarr; : &#x21b5; downwards arrow with corner leftwards
					 */, 8656/* &lArr; : &#x21d0; leftwards double arrow */,
				8657/* &uArr; : &#x21d1; upwards double arrow */,
				8658/* &rArr; : &#x21d2; rightwards double arrow */,
				8659/* &dArr; : &#x21d3; downwards double arrow */,
				8660/* &hArr; : &#x21d4; left right double arrow */,
				8704/* &forall; : &#x2200; for all */,
				8706/* &part; : &#x2202; partial differential */,
				8707/* &exist; : &#x2203; there exists */,
				8709/* &empty; : &#x2205; empty set */,
				8711/* &nabla; : &#x2207; nabla */,
				8712/* &isin; : &#x2208; element of */,
				8713/* &notin; : &#x2209; not an element of */,
				8715/* &ni; : &#x220b; contains as member */,
				8719/* &prod; : &#x220f; n-ary product */,
				8721/* &sum; : &#x2211; n-ary summation */,
				8722/* &minus; : &#x2212; minus sign */,
				8727/* &lowast; : &#x2217; asterisk operator */,
				8730/* &radic; : &#x221a; square root */,
				8733/* &prop; : &#x221d; proportional to */,
				8734/* &infin; : &#x221e; infinity */,
				8736/* &ang; : &#x2220; angle */,
				8743/* &and; : &#x2227; logical and */,
				8744/* &or; : &#x2228; logical or */,
				8745/* &cap; : &#x2229; intersection */,
				8746/* &cup; : &#x222a; union */,
				8747/* &int; : &#x222b; integral */,
				8756/* &there4; : &#x2234; therefore */,
				8764/* &sim; : &#x223c; tilde operator */,
				8773/* &cong; : &#x2245; congruent to */,
				8776/* &asymp; : &#x2248; asymptotic to */,
				8800/* &ne; : &#x2260; not equal to */,
				8801/* &equiv; : &#x2261; identical to */,
				8804/* &le; : &#x2264; less-than or equal to */,
				8805/* &ge; : &#x2265; greater-than or equal to */,
				8834/* &sub; : &#x2282; subset of */,
				8835/* &sup; : &#x2283; superset of */,
				8836/* &nsub; : &#x2284; not a subset of */,
				8838/* &sube; : &#x2286; subset of or equal to */,
				8839/* &supe; : &#x2287; superset of or equal to */,
				8853/* &oplus; : &#x2295; circled plus */,
				8855/* &otimes; : &#x2297; circled times */,
				8869/* &perp; : &#x22a5; up tack */,
				8901/* &sdot; : &#x22c5; dot operator */,
				8968/* &lceil; : &#x2308; left ceiling */,
				8969/* &rceil; : &#x2309; right ceiling */,
				8970/* &lfloor; : &#x230a; left floor */,
				8971/* &rfloor; : &#x230b; right floor */,
				9001/* &lang; : &#x2329; left-pointing angle bracket */,
				9002/* &rang; : &#x232a; right-pointing angle bracket */,
				9674/* &loz; : &#x25ca; lozenge */,
				9824/* &spades; : &#x2660; black spade suit */,
				9827/* &clubs; : &#x2663; black club suit */,
				9829/* &hearts; : &#x2665; black heart suit */,
				9830/* &diams; : &#x2666; black diamond suit */, };
		// allow 50% extra space for faster lookup.
		entityToChar = new HashMap<String, Character>(entityKeys.length * 150 / 100);
		for (int i = 0; i < entityKeys.length; i++) {
			// leave out nbsp so it can be specially handled if entity not
			// found.
			if (!entityKeys[i].equals("nbsp")) {
				entityToChar.put(entityKeys[i], entityValues[i]);
			}
			// add also &apos; for strip but not insert. optional for XML, not
			// used in HTML.
			entityToChar.put("apos", (char) 39);
		}
	}// end static

	/**
	 * Transform a list of properties in a String. Properties are separated by
	 * PROPERTY_SEPARATOR and name values by VALUE_SEPARATOR
	 * 
	 * @param props
	 * @return
	 */
	@SuppressWarnings("rawtypes")
	public static String properties2String(Properties props) {
		StringBuffer buf = null;

		if (props != null) {
			Enumeration propsEnum = props.propertyNames();

			while (propsEnum.hasMoreElements()) {
				String propertyName = (String) propsEnum.nextElement();
				String propertyValue = props.getProperty(propertyName);

				if (buf == null) {
					buf = new StringBuffer();
				} else {
					buf.append(PROPERTY_SEPARATOR);
				}

				buf.append(propertyName).append(VALUE_SEPARATOR).append(propertyValue);
			}
		}

		if (buf != null) {
			return buf.toString();
		} else {
			return null;
		}
	}

	/**
	 * Transform a list of properties in a String. Properties are separated by
	 * PROPERTY_SEPARATOR and name values by VALUE_SEPARATOR
	 * 
	 * @param props
	 * @return
	 */
	@SuppressWarnings("rawtypes")
	public static String map2String(Map map) {
		StringBuffer buf = null;

		if (map != null) {
			Iterator it = map.keySet().iterator();

			while (it.hasNext()) {

				if (buf == null) {
					buf = new StringBuffer();
				} else {
					buf.append(PROPERTY_SEPARATOR);
				}

				Object key = it.next();
				if (key != null) {
					buf.append(key.toString()).append(VALUE_SEPARATOR);

					Object value = map.get(key);
					if (value != null) {
						buf.append(value.toString());
					} else {
						buf.append("null");
					}
				}

			}
		}

		if (buf != null) {
			return buf.toString();
		} else {
			return null;
		}
	}

	/**
	 * @param propsString
	 * @return
	 */
	public static Properties string2Properties(String propsString) {
		Properties props = null;

		if ((propsString != null) && (propsString.length() > 0)) {
			StringTokenizer tokenizer = new StringTokenizer(propsString, PROPERTY_SEPARATOR);
			props = new Properties();

			while (tokenizer.hasMoreTokens()) {
				String propertyNameAndValue = tokenizer.nextToken();

				int index = propertyNameAndValue.indexOf(VALUE_SEPARATOR);

				if (index > 0) {
					String propertyName = propertyNameAndValue.substring(0, index).trim();
					String propertyValue = propertyNameAndValue.substring(index + 1).trim();
					props.setProperty(propertyName, propertyValue);
				}
			}
		}

		return props;
	}

	/**
	 * Transform a String array into a String. words are separated by
	 * PROPERTY_SEPARATOR
	 * 
	 * @param array
	 * @return string
	 */
	public static String stringArray2String(String[] array) {
		if ((array != null) && (array.length > 0)) {
			StringBuffer buf = null;

			for (int i = 0; i < array.length; i++) {
				if (buf == null) {
					buf = new StringBuffer();
				} else {
					buf.append(PROPERTY_SEPARATOR);
				}

				if (array[i] != null) {
					buf.append(array[i]);
				} else {
					buf.append("null");
				}
			}

			return buf.toString();
		}

		return null;
	}

	/**
	 * Replace a String by another one inside a String
	 * 
	 * @param original
	 *            the original String to replace in
	 * @param toReplace
	 *            the String to be replaced
	 * @param replacement
	 *            the replacing String
	 * @return the String with replacement done
	 */
	public static String replaceWord(String original, String toReplace, String replacement) {
		if (original == null)
			return null;
		int i = original.indexOf(toReplace);

		if (i < 0) {
			return original; // return original if 'toReplace' is not in it.
		}

		String partBefore = original.substring(0, i);
		String partAfter = original.substring(i + toReplace.length());

		// Replaces a null String by ""
		if (replacement == null) {
			return partBefore + "" + partAfter;
		} else {
			return partBefore + replacement + partAfter;
		}

	}

	public static String replaceAll(String original, String toReplace, String replacement) {
		if (original == null)
			return null;

		return original.replaceAll(toReplace, replacement);
	}

	/**
	 * Converts a color as a String to a java Color object.
	 * 
	 * @param s
	 *            string color <br>
	 *            Either s is a predefined color Name
	 *            (red,yellow,pink,cyan,blue,orange,magenta,white,gray,lightGray,darkGray,black)
	 *            or s is a HTML style color made up of a '#' + RGB hexadecimal
	 *            codes ( for instance: "#FF101D" )
	 * @return the <code>java.awt.Color</code> object.<br>
	 *         If an error occurs while parsing the String, it returns null.
	 */
	/*
	 * public static Color stringToColor(String s) { Color color = null; //
	 * default color
	 * 
	 * if (s == null) { return color; }
	 * 
	 * s = s.toLowerCase();
	 * 
	 * if (s.equals("red")) { color = Color.red; } else if (s.equals("yellow"))
	 * { color = Color.yellow; } else if (s.equals("pink")) { color =
	 * Color.pink; } else if (s.equals("green")) { color = Color.green; } else
	 * if (s.equals("cyan")) { color = Color.cyan; } else if (s.equals("blue"))
	 * { color = Color.blue; } else if (s.equals("orange")) { color =
	 * Color.orange; } else if (s.equals("magenta")) { color = Color.magenta; }
	 * else if (s.equals("white")) { color = Color.white; } else if
	 * (s.equals("gray")) { color = Color.gray; } else if
	 * (s.equals("lightgray")) { color = Color.lightGray; } else if
	 * (s.equals("darkgray")) { color = Color.darkGray; } else if
	 * (s.equals("black")) { color = Color.black; } else if ((s.length() == 7)
	 * && (s.charAt(0) == '#')) { // Convert string to hexadecimal values and to
	 * int values try { int r = Integer.parseInt(s.substring(1, 3), 16); int g =
	 * Integer.parseInt(s.substring(3, 5), 16); int b =
	 * Integer.parseInt(s.substring(5), 16); color = new Color(r, g, b); } catch
	 * (Exception e) { color = null; } }
	 * 
	 * return color; }
	 */

	/**
	 * Replace the last char of original with newString
	 * 
	 * @param original
	 *            the original String to replace in
	 * @param newString
	 *            the replacing String
	 * @return the String with replacement done
	 */
	public static String replaceLastChar(String original, String newString) {
		if ((original == null) || (original == "")) {
			return null;
		}

		int length = original.length();

		if (length == 1) {
			return newString;
		}

		String substr = original.substring(0, length - 1);

		return substr + newString;
	}

	/**
	 * Finds a keyword rank into a keywords list.<br>
	 * This is useful to use' switch case' with Strings instead of 'else
	 * if'.<br>
	 * 
	 * <strong>Example of Use</strong><br>
	 * <blockquote>
	 * 
	 * <pre>
	 * String[] formatList = { &quot;number&quot;, &quot;date&quot;, &quot;time&quot; };
	 * String formatName = &quot;number&quot;;
	 * 
	 * switch (StringUtils.findKeyword(formatName, formatList)) {
	 * case 0: // number
	 * 	System.out.println(&quot;The format is number&quot;);
	 * 	break;
	 * case 1: // date
	 * 	System.out.println(&quot;The format is date&quot;);
	 * 	break;
	 * case 2: // time
	 * 	System.out.println(&quot;The format is time&quot;);
	 * 	break;
	 * }
	 * 
	 * </pre>
	 * 
	 * </blockquote><br>
	 * This search is not case sensitive.
	 * 
	 * @param s
	 *            the keyword to find.
	 * @param list
	 *            the keywords list.
	 * @return the keyword rank into the list. -1 if not found, or s is null
	 */
	public static final int findKeyword(String s, String[] list) {
		if (s == null) {
			return -1;
		}

		s = s.trim().toLowerCase();

		for (int i = 0; i < list.length; ++i) {
			if (s.equals(list[i].toLowerCase())) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Read a file and puts its content into a String<br>
	 * Return null if the file is not found or cannot be read
	 * 
	 * @param fileName
	 *            the name of the file to read.
	 * @return String the Content of the file.
	 */
	public static String readFileToString(String fileName) {
		StringBuffer buf = new StringBuffer();
		BufferedReader in = null;
		try {
			FileReader file = new FileReader(fileName);
			in = new BufferedReader(file);
			String line;

			while ((line = in.readLine()) != null) {
				buf.append(line);
				buf.append(System.getProperty("line.separator"));
			}

			in.close();
		} catch (IOException e) {
			System.out.println("Exception: " + e.toString());

			return null;
		} finally {
			try {
				in.close();
			} catch (IOException e) {
				// No Action
			}
		}

		return buf.toString();
	}

	/**
	 * search if a string contains a given substring. <BR>
	 * The search can be customized imposing that the substring <BR>
	 * starts at a given index and ends at an other given index. <BR>
	 * (The given index are inclusive)
	 * 
	 * contains("professionnal","rof",0,12) returns true. <BR>
	 * contains("professionnal","rof",1,3) returns true. <BR>
	 * contains("professionnal","rof",2,12) returns false. <BR>
	 * contains("professionnal","rof",0,2) returns false. <BR>
	 * contains("professionnal","azerty",0,12) returns false. <BR>
	 * 
	 * @param original
	 *            - the original string
	 * @param small
	 *            - a smaller string
	 * @param firstIndex
	 *            - the index in original where the search starts
	 * @param lastIndex
	 *            - the index in original where the search ends
	 * @return a boolean returning if small is contained in original
	 */
	public static boolean contains(String original, String small, int firstIndex, int lastIndex) {
		if ((original == null) || (small == null)) {
			return false;
		}

		if ((firstIndex < 0) || (lastIndex < firstIndex) || (lastIndex >= original.length())) {
			return false;
		}

		if ((lastIndex - firstIndex + 1) < small.length()) {
			return false;
		}

		int smallSize = small.length();

		for (int i = firstIndex; i <= (lastIndex - smallSize + 1); i++) {
			if (small.equals(original.substring(i, i + smallSize))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Ths method enables sorting alphabetically a vector of Strings.<BR>
	 * The input vector must absolutely contains String and no other type .
	 * 
	 * @param String
	 *            vector
	 *//*
		 * public static void sortStringVector(Vector v) { if (v != null) { int
		 * i = 0; int size = v.size(); int j; String tmp; boolean continueSort =
		 * true;
		 * 
		 * // begin of the sort : algorithm of the "bubble sort" while (i <
		 * size) { j = i; continueSort = true;
		 * 
		 * while ((j != 0) && continueSort) { if ((String) v.elementAt(j) ==
		 * null) { v.set(j, ""); }
		 * 
		 * if (((String) v.elementAt(j)).compareTo((String) v.elementAt(j - 1))
		 * < 0) { tmp = (String) v.elementAt(j - 1); v.set(j - 1, (String)
		 * v.elementAt(j)); v.set(j, tmp); j--; } else { continueSort = false; }
		 * }
		 * 
		 * i++; } } }
		 */

	/**
	 * Replace a list of comma-separated values by a list of comma + quote
	 * separated values As for a SQL select for in clause.<br>
	 * <b>Example</b><br>
	 * if input is: <code>value1,value2,value3</code> returned value is
	 * <code>('value1','value2',value3')</code>
	 * 
	 * @param inString
	 * @return the
	 */
	public static String listOfCommaSeparatedValuesToSQLInListOfValues(String inString) {

		String sqlString = null;

		if ((inString != null) && (inString.contains(COMMA_SEPARATED_VALUES_SEPARATOR))) {

			String replacedString = inString.replaceAll(COMMA_SEPARATED_VALUES_SEPARATOR, SQL_IN_VALUES_SEPARATOR);
			sqlString = SQL_IN_START + replacedString + SQL_IN_END;

		} else if (inString != null && !"".equals(inString)) {
			sqlString = SQL_IN_START + inString + SQL_IN_END;
		}

		return sqlString;

	}

	/**
	 * Remove all non CSV compatible character in the input String: remove new
	 * line character, remove comma
	 * 
	 * @param inString
	 * @return
	 */
	public static String formatToCSVCompatibleString(String inString) {
		String outString = null;

		if (inString == null) {
			outString = "";
		} else {
			String tmp1 = inString.replaceAll("\"", "\"\"");
			String tmp2 = tmp1.replaceAll("\r\n", " ");
			String tmp3 = tmp2.replace('\n', ' ');
			outString = tmp3;
		}

		return outString;
	}

	/**
	 * Remove all non CSV compatible character in the input String: remove new
	 * line character, remove comma
	 * 
	 * @param inString
	 * @return
	 */
	public static String formatDocCompatiableString(String inString) {
		String outString = null;

		if (inString == null) {
			outString = "";
		} else {
			String tmp2 = inString.replaceAll("\r\n", "\n");
			outString = tmp2;
		}

		return outString;
	}

	/**
	 * Remove all non ascii
	 * 
	 * @param inString
	 * @return
	 */
	public static String filterNonAsciiCharacters(String inString) {

		StringBuffer sb = new StringBuffer("");

		for (int i = 0; (inString != null) && (i < inString.length()); i++) {
			char c = inString.charAt(i);
			int charCode = (int) c;
			// System.out.println(charCode);

			if (isLayoutChar(c)) {
				sb.append(c);
			} else if ((charCode < 127) && (charCode > 32)) {
				sb.append(c);
			}
			// French characters
			else if (isFrenchChar(charCode)) {
				sb.append(c);
			} else if ((charCode > 223) && (charCode < 229)) {
				sb.append(c);
			}
			// other chars
			else if (isOtherChar(c)) {
				sb.append(c);
			}
		}

		return sb.toString();
	}

	private static boolean isOtherChar(char c) {
		return true;
	}

	private static boolean isFrenchChar(int charCode) {
		return (charCode > 230) && (charCode < 236);
	}

	public static String replaceAll(String original) {

		String leftDoubleQuote = "&#8220;";
		String rightDoubleQuote = "&#8221;";
		String replacement = "\"";
		String leftQuote = "&#8216;";
		String rightQuote = "&#8217;";
		String replacement2 = "\'";

		if (original == null)
			return null;

		String s = original.replaceAll(leftDoubleQuote, replacement);
		s = s.replaceAll(rightDoubleQuote, replacement);
		s = s.replaceAll(leftQuote, replacement2);
		s = s.replaceAll(rightQuote, replacement2);
		return s;
	}

	/**
	 * Replace a list of comma-separated values by a list of comma + quote
	 * separated values As for a SQL select for in clause.<br>
	 * <b>Example</b><br>
	 * if input is: <code>value1,value2,value3</code> returned value is
	 * <code>('value1','value2',value3')</code>
	 * 
	 * @param inString
	 * @return the
	 */
	public static String listToCommaSeparatedValues(List<String> list) {

		StringBuilder sb = new StringBuilder();
		for (String e : list) {
			if (sb.length() > 0)
				sb.append(',');
			sb.append(e);
		}
		return sb.toString();

	}

	public static List<String> stringWithDelimeterToList(String str, String delimeter) {

		List<String> strList = new ArrayList<String>();
		StringTokenizer strTok = new StringTokenizer(str, delimeter);
		while (strTok.hasMoreTokens()) {
			strList.add(strTok.nextToken());
		}
		return strList;

	}

	public static boolean isInvalidCharSet(String value) {

		String[] ExcludeChar = new String[11];
		ExcludeChar[0] = "<";
		ExcludeChar[1] = "</";
		ExcludeChar[2] = "<script>";
		ExcludeChar[3] = "<html>";
		ExcludeChar[4] = "</script>";
		ExcludeChar[5] = "<object>";
		ExcludeChar[6] = "<applet>";
		ExcludeChar[7] = "<embed>";
		ExcludeChar[8] = "www.";
		ExcludeChar[9] = "http:";
		ExcludeChar[10] = "javascript:";

		for (int k = 0; k < ExcludeChar.length; k++) {
			if (value.indexOf(ExcludeChar[k]) != -1) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Remove all special characters
	 * 
	 * @param inString
	 * @return
	 */
	public static String filterSpecialCharacters(String inString) {

		inString = resolveEntities(inString);

		StringBuffer sb = new StringBuffer("");

		for (int i = 0; (inString != null) && (i < inString.length()); i++) {
			char c = inString.charAt(i);
			int charCode = (int) c;

			// layout characters
			// ----------------------------------------------------
			if (isLayoutChar(c)) {
				sb.append(c);
			}
			// 'Normal' characters
			// ----------------------------------------------------
			else if (isNormalCharacter(charCode)) {
				sb.append(c);
			}

			// characters with accents (French and others)
			// ----------------------------------------------------
			else if (isFrenchA(charCode)) {
				sb.append('A');
			} else if (charCode == 199) {
				sb.append('C');
			} else if (isFrenchE(charCode)) {
				sb.append('E');
			} else if (isFrenchI(charCode)) {
				sb.append('I');
			} else if (isFrenchO(charCode)) {
				sb.append('O');
			} else if (isFrenchU(charCode)) {
				sb.append('U');
			} else if (isFrenchCharA(charCode)) {
				sb.append('a');
			} else if (charCode == 231) {
				sb.append('c');
			} else if (isFrenchCharE(charCode)) {
				sb.append('e');
			} else if (isFrenchCharI(charCode)) {
				sb.append('i');
			} else if (isFrenchCharO(charCode)) {
				sb.append('o');
			} else if (isFrenchCharU(charCode)) {
				sb.append('u');
			}

			// Special characters
			// ----------------------------------------------------
			// artistic '
			else if (isArtisticQuote(charCode)) {
				sb.append('\'');
			}
			// artistic "
			else if (isArtisticDoubleQuote(charCode)) {
				sb.append('"');
			}
			// one character for ...
			/*
			 * else if (charCode == 133) { sb.append('.'); }
			 */

			// Special HTML characters
			// ----------------------------------------------------
			// single quote '
			else if (isSingleQuote(charCode)) {
				sb.append('\'');
			}
			// double quote "
			else if (isDoubleQuote(charCode)) {
				sb.append('"');
			}
			// one character for ...
			/*
			 * else if (charCode == 133) { sb.append('.'); }
			 */
			// dash characters
			else if (isHiphen(charCode)) {
				sb.append('-');
			}

			// replace by space to maintain length
			// ----------------------------------------------------
			else {
				sb.append(' ');
			}
		}
		return sb.toString();
	}

	private static boolean isHiphen(int charCode) {
		return (charCode == 8211) || (charCode == 8212);
	}

	private static boolean isFrenchCharU(int charCode) {
		return (charCode >= 249) && (charCode <= 252);
	}

	private static boolean isFrenchCharO(int charCode) {
		return (charCode >= 242) && (charCode <= 246);
	}

	private static boolean isFrenchCharI(int charCode) {
		return (charCode >= 236) && (charCode <= 239);
	}

	private static boolean isFrenchCharE(int charCode) {
		return (charCode >= 232) && (charCode <= 235);
	}

	private static boolean isDoubleQuote(int charCode) {
		return (charCode >= 8220) && (charCode <= 8222);
	}

	private static boolean isSingleQuote(int charCode) {
		return (charCode >= 8216) && (charCode <= 8218);
	}

	private static boolean isArtisticDoubleQuote(int charCode) {
		return (charCode == 147) || (charCode == 148) || (charCode == 171) || (charCode == 187);
	}

	private static boolean isArtisticQuote(int charCode) {
		return (charCode == 145) || (charCode == 146);
	}

	private static boolean isFrenchCharA(int charCode) {
		return (charCode >= 224) && (charCode <= 230);
	}

	private static boolean isFrenchU(int charCode) {
		return (charCode >= 217) && (charCode <= 220);
	}

	private static boolean isFrenchO(int charCode) {
		return (charCode >= 210) && (charCode <= 214);
	}

	private static boolean isFrenchI(int charCode) {
		return (charCode >= 204) && (charCode <= 207);
	}

	private static boolean isFrenchE(int charCode) {
		return (charCode >= 200) && (charCode <= 203);
	}

	private static boolean isFrenchA(int charCode) {
		return (charCode >= 192) && (charCode <= 198);
	}

	private static boolean isNormalCharacter(int charCode) {
		return (charCode >= 32) && (charCode < 127);
	}

	private static boolean isLayoutChar(char c) {
		return (c == '\n') || (c == '\r') || (c == '\t');
	}

	/**
	 * Replace into a String all the HTML entities by the equivalent character.
	 * Entities can be numerical (&#8216;) or string entities : (&gt;)
	 * 
	 * @param str
	 *            the input String to filter
	 * @return filtered String, all entities have been converted into characters
	 */
	public static String resolveEntities(String str) {
		// Code Pattern for numerical entities :
		Pattern codePattern = Pattern.compile("#[0-9]+");

		// Pattern representing an HTML entity :
		// Pattern pattern = Pattern.compile("&(.+?);");
		Pattern pattern = Pattern.compile("&([#a-zA-Z0-9]+);");
		Matcher matcher = pattern.matcher(str);

		// Find the first Entity
		if (matcher.find()) {
			// create a StringBuffer to store modified String :
			StringBuffer buffer = new StringBuffer(str.length());

			do {
				String replacement;
				// Get the value :
				String entity = matcher.group(1);

				// If the entity is a numerical entity #123,
				// convert the number into an int, then into a char :
				if (codePattern.matcher(entity).matches()) {
					char c = (char) Integer.parseInt(entity.substring(1));
					replacement = Character.toString(c);
				} else {
					// otherwise (string entity) try to find i in the list
					Character replacementChar = entityToChar.get(entity);
					if (replacementChar == null) {
						replacement = " "; // replace by space the not found
											// entities
					} else
						replacement = replacementChar.toString();
				}
				// Adding in buffer by replacing :
				matcher.appendReplacement(buffer, replacement);

			} while (matcher.find());
			matcher.appendTail(buffer);

			return buffer.toString();
		}
		return str;
	}

	/**
	 * Added By Vivek This function checks if the string is valid or not
	 **/
	public static boolean isValidString(String str) {
		if (str != null && str.trim().length() > 0) {
			return true;
		}
		return false;
	}

	/**
	 * Added By Vivek This function can be used for escaping the wild characters
	 **/
	public static String escapeWildCharacters(String str) {
		StringBuilder tempStr = new StringBuilder();
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '_' || str.charAt(i) == '%') {
				tempStr.append("\\").append(str.charAt(i));
			} else {
				tempStr.append(str.charAt(i));
			}
		}
		return tempStr.toString();
	}

	public static String getCodeFromCodeDescr(String str) {
		String code = str;

		if (str != null && !"".equals(str) && str.contains("-"))
			code = str.substring(0, str.indexOf('-'));

		return code;
	}

	public static String replaceSpecialCharacterForJson(String str) {
		if (str != null) {
			str = str.replaceAll("\n", "\\\\n");
			str = str.replaceAll("\r", "\\\\r");
			str = str.replaceAll("\b", "\\\\b");
			str = str.replaceAll("\t", "\\\\t");
			str = str.replaceAll("\f", "\\\\f");
			str = str.replaceAll("'", "\\\\'");
		}
		return str;
	}

	public static String removeSemiColon(String name) {

		if (name != null) {
			int index = name.indexOf(";");
			if (index != -1) {
				if (index == 0)
					name = name.substring(index + 1, name.length());
				else
					name = name.substring(0, index - 1) + name.substring(index + 1, name.length());
			}
		}
		return name;
	}

	public static String convertNullToBlank(String name) {
		if (name == null) {
			return "";
		}
		return name;
	}

	public static boolean containsSplChrs(String inputStr) {

		boolean splchr_flag = false;

		String[] splChrs = { "#", "^", "%", "||", "script", "alert", "truncate", "delete", "insert", "drop", "xp_", "<",
				">", "html", "<div>", "`", "input" };
		for (int i = 0; i < splChrs.length; i++) {
			if (inputStr.indexOf(splChrs[i]) >= 0) {
				splchr_flag = true; // bad character are available
				break;
			}
		}
		return splchr_flag;
	}

	public static String join(List<String> list, String delimeter) {
		StringBuilder sb = new StringBuilder();
		boolean first = true;
		for (String item : list) {
			if (first) {
				first = false;
			} else {
				sb.append(delimeter);
			}
			sb.append(item);
		}
		return sb.toString();
	}

}
